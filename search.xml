<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[STM8L时钟寄存器]]></title>
    <url>%2F2018%2F02%2F24%2FSTM8L%E6%97%B6%E9%92%9F%E5%AF%84%E5%AD%98%E5%99%A8%2F</url>
    <content type="text"><![CDATA[#1.CLK_CKDIVR2-0:CKM[2:0]:系统时钟分频000: System clock source/1001: System clock source/2010: System clock source/4011: System clock source/8100: System clock source/16101: System clock source/32110: System clock source/64111: System clock source/128 #2.CLK_CRTCR7-5:RTCDIV[2:0]:RTC时钟分频4-1:RTCSEL[3:0]:RTC时钟源选择]]></content>
      <categories>
        <category>硬件编程</category>
      </categories>
      <tags>
        <tag>STM8</tag>
        <tag>CLK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DEBUG常用功能]]></title>
    <url>%2F2018%2F02%2F12%2FDEBUG%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[window 10中DEBUG的安装以及DEBUG调试中一些常用的命令 1.安装window 10中好像已经没有了Debug的调试工具，需要下载另外的软件 下载安装DOSBox.百度云下载地址：DOSBOX下载后先安装DOSBox0.74-win32-installer.exe然后找到文件dos-box0.74.conf(C:\Users\username\AppData\Local\DOSBox)添加两行12MOUNT C E:\DEBUG # 将目录E:\DEBUG挂载为DOSBOX下的C: set PATH=$PATH$;E:\DEBUG # 将E:\DEBUG写入环境变量PATH中 并将下载的MASM.exe,LINK.exe,debug.exe三个文件放入目录E:\DEBUG打开软件，输入c:就可以使用debug命令了 2.常用命令:R命令：查看改变CPU寄存器的内容D命令：查看内存中的内容E命令：改写内存中的内容U命令：将内存中的机器指令翻译成汇编指令T命令：执行一条机器指令A命令：以汇编指令的格式在内存中写入一条机器指令Q命令：退出DEBUG调试2018-02-12 21:50:06 3.命令具体使用实例3.1R命令：R命令：查看改变CPU寄存器的内容12-r ;显示寄存器的值-r reg ;改变寄存器reg的值 3.2D命令：D命令：查看内存中的内容默认显示128字节的内容123-d ;默认地址-d 段地址:偏移地址 ;指定地址-d 段地址:偏1 偏2 ;两个地址间的内容 3.3E命令：E命令：改写内存中的内容12-e 起始地址 数据 数据 ... -e 起始地址 3.4U命令：U命令：将内存中的机器指令翻译成汇编指令与D命令有些类似 3.5T命令：T命令：执行内存中的一条机器指令指令位置由cs:ip确定 3.6A命令：A命令：以汇编指令的格式在内存中写入一条机器指令2018-02-13 22:41:40]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>DEBUG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单了解汇编]]></title>
    <url>%2F2018%2F02%2F11%2F%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E6%B1%87%E7%BC%96%2F</url>
    <content type="text"><![CDATA[一些汇编的基础知识 1.汇编是什么汇编语言的主体是汇编指令，汇编指令是由机器指令发展而来，例如：操作：将寄存器bx的内容送到ax机器指令：101100000000000000000011记起来太过于复杂，从而有了替代它的汇编指令：mov ax,bx方便记忆，也符合人们的逻辑思维程序员们编写汇编指令，在通过编译器编译成机器指令，然后就可以在计算机中运行了（如今的大部分高级语言是通过编译器，将高级语言转换成汇编语言，在编译成机器语言在电脑中运行）不管什么语言，都要转换成机器语言在电脑中运行，汇编语言和高级语言都是人们为了简化程序制作过程而已 2.计算机的总线从逻辑上总线分为三类（8086）数据总线：传送数据，总线宽度决定一次读取数据多少（16）地址总线：指定地址，总线宽度决定寻址能力（20）控制总线：控制读写 3.存储器RAM：程序和数据都要加载到RAM即内存中，才能通过CPU运行，可读可写ROM：一些芯片的主要参数，及操作指令，芯片出厂时已经固定，仅可读计算机运行时，全部程序和数据都要加载到RAM中通过ROM中的一些必要信息，CPU才能对外设进行操作]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>x8086</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用中的一些问题]]></title>
    <url>%2F2018%2F01%2F22%2FGit%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[总结使用git的过程中遇到的问题 #1.配置问题全局配置123$ git config --list 查看当前用户信息$ git config --global user.name &quot;username&quot; 配置用户名$ git config --global user.email emailname@example.com 配置邮箱 项目配置(进入项目目录)123$ cat .git/config 项目配置信息$ git config user.name &quot;username&quot; 配置用户名$ git config user.email emailname@example.com 配置邮箱 全局的配置就是加上--global项目未设置的配置默认使用全局配置 #2.密钥问题123$ cd ~/.ssh 查看是否存在密钥$ ssh-keygen -t rsa -C &quot;emailname@example.com&quot; 生成密钥$ ssh -T git@github.com 测试是否配置成功 生成密钥过程中回车三次，是密码为空，不然每次push都要输入密码生成密钥后主要有两个文件~/.ssh/id_rsa私钥进行处理后的一些内容~/.ssh/id_rsa.pub公钥进行处理后的内容，提交到服务器(github或coding)的内容~/.ssh/known_hosts这个文件可能会有，是ssh对服务短的一些记录 #参考资料1,https://www.cnblogs.com/hustskyking/p/problems-in-git-when-ssh.html2,http://blog.csdn.net/u013626215/article/details/51508085]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Altium快捷键]]></title>
    <url>%2F2017%2F12%2F31%2FAltium%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[快捷键使用ctrl+shft+T(top)：上对齐ctrl+shft+B(bottom):下对齐ctrl+shft+L(left):左对齐ctrl+shft+T(right):右对齐ctrl+shft+H(horizonta):水平方向上等距ctrl+shft+V(vertical):竖直方向上的等距]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>Altium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算的妙用之二进制1的个数]]></title>
    <url>%2F2017%2F12%2F30%2F%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%A6%99%E7%94%A8%E4%B9%8B%E4%BA%8C%E8%BF%9B%E5%88%B61%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：求出一个正整数转换成二进制形式中数字”1”的个数如：int 型数值为 80转化成二进制形式：80 = 00000000 00000000 00000000 01010000因此 1 的个数为 2 1.普通解法一位一位判断123456789int bitCount1(int n) &#123; int count = 0; while (n != 0) &#123; if (n &amp; 0x01 == 1) count++; n = n &gt;&gt; 1; &#125; return count;&#125; 2.大神的解法算法分析看参考12345678int bitCount2(int n) &#123; n = n - ((n &gt;&gt; 1) &amp; 0x55555555);//n = (n &amp; 0x55555555) + ((n &gt;&gt; 1) &amp; 0x55555555); n = (n &amp; 0x33333333) + ((n &gt;&gt; 2) &amp; 0x33333333); n = (n &amp; 0x0f0f0f0f) + ((n &gt;&gt; 4) &amp; 0x0f0f0f0f); n = n + (n &gt;&gt; 8); //n = (n &amp; 0x00ff00ff) + ((n &gt;&gt; 8) &amp; 0x00ff00ff); n = n + (n &gt;&gt; 16); //n = (n &amp; 0x0000ffff) + ((n &gt;&gt; 16) &amp; 0x0000ffff); return n &amp; 0x0000003f; //return n;&#125; 参考文章1.https://www.jianshu.com/p/25c75149e7a22017-12-30 16:32:32]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python遇到的错误]]></title>
    <url>%2F2017%2F12%2F26%2Fpython%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[python使用在中遇到的错误 python ImportError: DLL load failed: %1 不是有效的 Win32 应用程序解决方法：去下载与你所安装的Python版本对应的pywin32并安装下载链接：https://sourceforge.net/projects/pywin32/files/pywin32/对应版本和位数Python 2.7.13 (v2.7.13:a06454b1afa1, Dec 17 2016, 20:42:59) [MSC v.1500 32 bit (Intel)] on win32Type “help”, “copyright”, “credits” or “license” for more information.还有一种可能是导入的模块是64位的，而你的python是32位的参考: http://blog.csdn.net/sinat_34615726/article/details/67636949 2017-12-26 15:41:42]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串匹配]]></title>
    <url>%2F2017%2F12%2F21%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[1.BM算法 2.KMP算法 1.BM算法从左到右依次比较s:主串r:模式串1234567891011121314int BM(char *s,int slen,char *r,int rlen)&#123; int i=1,j=1; while(i&lt;=slen-rlen+1)&#123; while(j&lt;=rlen&amp;&amp;s[i]==r[j])&#123; i++;j++; &#125; if(j&gt;rlen)&#123; return i-j+1; &#125;else&#123; j=1;i++; &#125; &#125; return 0;&#125; 2.KMP算法通过一个next数字当每次发生不匹配的时候模式串不必回到开头12345678910111213141516171819202122232425262728293031int* getnext(char *r, int n) &#123; //next数组求解 int i, j; int *next = (int *)malloc((n + 1) * sizeof(int)); next[0] = n; next[1] = 0; j = 0; i=1; while(i&lt;n)&#123; if (j == 0 || r[i] == r[j]) &#123; ++i; ++j; next[i] = j; &#125; else &#123; j = next[j]; &#125; &#125; return next;&#125;int KMP(char *s,int slen,char *r,int rlen)&#123; int *next=getnext(r,rlen); int i=1,j=1; while(i&lt;=slen&amp;&amp;j&lt;=rlen)&#123; while(j&lt;=rlen&amp;&amp;s[i]==r[j])&#123; i++;j++; &#125; if(j&gt;rlen)&#123; return i-j+1; &#125;else&#123; j=next[j];i++; &#125; &#125; return 0;&#125; 2017-12-21 20:57:49 参考文章1.字符串模式匹配的BM算法2.字符串匹配的KMP算法]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime_Text3插入当前时间]]></title>
    <url>%2F2017%2F12%2F21%2Fsublime_Text3%E6%8F%92%E5%85%A5%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[1.创建新snippettool → new snippet 创建一个新的snippet,并保存为”author.sublime-snippet”(最好在该目录(User)下再创建一个MySnippet目录):其内容:123456789101112131415&lt;snippet&gt;&lt;content&gt;&lt;![CDATA[/** * ============================ * @Author: XX * @Version: 1.0 * @DateTime: $&#123;1:alt+t&#125; * ============================ */]]&gt;&lt;/content&gt; &lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt; &lt;tabTrigger&gt;author&lt;/tabTrigger&gt; &lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt; &lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt;&lt;/snippet&gt; 2.创建新插件Tools → New Plugin. 创建时间插件,保存在User目录,命名为addCurrentTime.py:其内容为:123456789import sublime, sublime_pluginimport datetimeclass AddCurrentTimeCommand(sublime_plugin.TextCommand): def run(self, edit): self.view.run_command("insert_snippet", &#123; "contents": "%s" % datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S") &#125; ) 3.绑定快捷键Preference → Key Bindings → User.绑定快捷键:12345678[ &#123; &quot;command&quot;: &quot;add_current_time&quot;, &quot;keys&quot;: [ &quot;alt+t&quot; ] &#125;] 其中绑定的命令的名字是由所创建的插件的类名而来AddCurrentTimeCommand–&gt;add_current_time这应该是Sublime创建插件的规则 参考资料1,http://www.cnblogs.com/xiaomingzaixian/p/6984664.html2,http://blog.csdn.net/sshfl_csdn/article/details/46415551]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言文件读写]]></title>
    <url>%2F2017%2F12%2F12%2FC%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%2F</url>
    <content type="text"><![CDATA[C语言文件操作笔记123456FILE *fopen(char *filename,char *type); //打开文件int fclose(FILE *stream); //关闭文件int fgetc(FILE *stream); //读一个字符指针后移int getc(FILE *stream);int fputc(int ch,FILE *stream); //写一个字符指针后移int putc(int ch,FILE *stream); filename指明文件路径type可取的至如下“r” :打开一个已有的文本文，允许读取文件“w” :打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容“a” :打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。“r+”:打开一个文本文件，允许读写文件“w+”:打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件“a+”:打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式:&quot;rb&quot;, &quot;wb&quot;, &quot;ab&quot;, &quot;rb+&quot;, &quot;r+b&quot;, &quot;wb+&quot;, &quot;w+b&quot;, &quot;ab+&quot;, &quot;a+b&quot;2017-12-31 13:58:16]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片头文件解析]]></title>
    <url>%2F2017%2F12%2F12%2F%E5%9B%BE%E7%89%87%E5%A4%B4%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1.PNG图片文件头PNG图像格式文件由一个8字节的PNG文件标识（file signature）域和3个以上的后续数据块（IHDR、IDAT、IEND）组成。PNG文件包括8字节文件署名（89 50 4E 47 0D 0A 1A 0A，十六进制），用来识别PNG格式。 十六进制 含义 89 用于检测传输系统是否支持8位的字符编码（8 bit data），用以减少将文本文件被错误的识别成PNG文件的机会，反之亦然。 50 4E 47 PNG每个字母对应的ASCII，让用户可以使用文本编辑器查看时，识别出是PNG文件。 0D 0A DOS风格的换行符（CRLF）。用于DOS-Unix数据的换行符转换。 1A 在DOS命令行下，用于阻止文件显示的文件结束符。 0A Unix风格的换行符（LF）。用于Unix-DOS换行符的转换。]]></content>
      <categories>
        <category>文件</category>
      </categories>
      <tags>
        <tag>文件头</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS自带python2.6升级到2.7]]></title>
    <url>%2F2017%2F09%2F12%2FCentOS%E8%87%AA%E5%B8%A6python2-6%E5%8D%87%E7%BA%A7%E5%88%B02-7%2F</url>
    <content type="text"><![CDATA[下载python2.71[root@host ~]# wget http://python.org/ftp/python/2.7.3/Python-2.7.3.tar.bz2 解压并更改目录12[root@host ~]# tar -jxvf Python-2.7.3.tar.bz2[root@host ~]# cd Python-2.7.3 编译安装12345[root@host Python-2.7.3]# ./configure[root@host Python-2.7.3]# make all[root@host Python-2.7.3]# make install[root@host Python-2.7.3]# make clean[root@host Python-2.7.3]# make distclean 安装需要gcc(如果系统没有gcc需要自己安装)1[root@host Python-2.7.3]# yum install -y gcc 查看版本信息1234[root@host ~]# /usr/local/bin/python2.7 -VPython 2.7.3[root@host ~]# python -VPython 2.6.6 python2.7已经安装,但系统的python还是2.6 建立软连接，使系统默认的python指向python2.712rm /usr/bin/python /usr/bin/python2.6ln -s /usr/local/bin/python2.7 /usr/bin/python 但yum命令依赖python2.6.6，需要更改一些配置文件12su root ##切换到root vi /usr/bin/yum ##打开文件 /usr/bin/python ##删除此行/usr/bin/python2.6.6 ##改为此行更改需要管理员权限 参考:http://blog.csdn.net/jcjc918/article/details/11022345]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VC6聊天室程序设计]]></title>
    <url>%2F2017%2F09%2F11%2FVC6%E8%81%8A%E5%A4%A9%E5%AE%A4%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[了解了C语言多线程的实例和简单的TCP通信，来编写一个简单的聊天室曾经java实现的聊天室程序在这里客户端程序客户端需要两个线程，主线程接受用户输入并发送到服务器另一个线程监听服务器发来的消息，显示在屏幕上123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include "winsock2.h"#include "stdio.h"#define SERVER_IP "10.80.167.248"#define SERVER_PORP 8884//blog:zfblog.xyz//author:FreyDWORD WINAPI ThreadFun(LPVOID pM) &#123; SOCKET sockClient=*(SOCKET *)pM; char recvInfo[100]; while(1) &#123; if(recv(sockClient,recvInfo,100,0)&gt;0) &#123; printf("%s",recvInfo); &#125; &#125; return 0;&#125;void main()&#123; //加载套接字库 WORD wVersionRequested; WSADATA wsaData; int err; wVersionRequested = MAKEWORD( 1, 1 ); //版本好为1.1 err = WSAStartup( wVersionRequested, &amp;wsaData ); if ( err != 0 ) &#123; return; &#125; if ( LOBYTE( wsaData.wVersion ) != 1 || HIBYTE( wsaData.wVersion ) != 1 ) &#123; WSACleanup( ); return; &#125; SOCKET sockClient=socket(AF_INET,SOCK_STREAM,0); //SOCK_STREAM参数设置为TCP连接 SOCKADDR_IN addrServer; //服务器地址结构 addrServer.sin_addr.S_un.S_addr=inet_addr(SERVER_IP); //服务器地址 addrServer.sin_port=htons(SERVER_PORP); //服务器端口号 addrServer.sin_family=AF_INET; //与服务器端建立连接，进行通信 char name[100]; printf("请输入姓名:"); scanf("%s",name); int connReult=connect(sockClient,(SOCKADDR*)&amp;addrServer,sizeof(SOCKADDR)); if(connReult!=WSAEADDRNOTAVAIL) //访问成功 &#123; CreateThread(NULL, 0, ThreadFun, (void *)&amp;sockClient, 0, NULL); printf("连接成功\n"); //成功建立连接后向服务器端发送数据，结果将显示在服务器端上 char sendInfo[100]; sprintf(sendInfo,name); send(sockClient,sendInfo,strlen(sendInfo)+1,0); //接收来自服务器端发送来的信息 //char recvInfo[100]; //recv(sockClient,recvInfo,100,0); //printf("%s\n",recvInfo); while(1) &#123; scanf("%s",sendInfo); send(sockClient,sendInfo,strlen(sendInfo)+1,0); &#125; &#125; else &#123; int errCode=WSAGetLastError(); printf("the errcode is:%d\n",errCode); &#125; closesocket(sockClient); WSACleanup();&#125; 服务器程序用一个链表来存储用户的套接字和姓名主线程监听用户的连接，每当有新用户连接，将其信息加入链表，并传入第二个线程第二个线程接受客户端发来的信息，并将信息传入第三个线程第三个线程从链表中读取用户套接字，将接到的信息转发给所有在线用户123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include "winsock2.h"#include "stdio.h"#include &lt;windows.h&gt;//blog:zfblog.xyz//author:Frey#define SERVER_PORP 8884struct client_info&#123; SOCKET sockConn; char name[100]; client_info *next;&#125;;//存放每一个用户的信息client_info * C_info_head;DWORD WINAPI Threadmes(LPVOID pM)&#123; char sendInfo[100]; sprintf(sendInfo,(char *)pM); for(int i=0;i&lt;=c_info_num;i++)&#123; SOCKET sockConn=C_info[i].sockConn; //if(C_info[i].num!=-1)&#123; send(sockConn,sendInfo,strlen(sendInfo)+1,0); //&#125; &#125; return 0;&#125;//将某条消息群发给所有客户端void sendmessage(char *message)&#123; CreateThread(NULL, 0, Threadmes, (void *)message, 0, NULL);&#125;//接收每个用户的信息DWORD WINAPI ThreadFun(LPVOID pM) &#123; client_info c_info = *(client_info *)pM; SOCKET sockConn=c_info.sockConn; char sendInfo[100]; //inet_ntoa将结构转换为十进制的IP地址字符串 //sprintf(sendInfo,"welcome %s to this Server!",inet_ntoa(addrClient.sin_addr)); //成功建立连接后向客户端发送数据，结果将显示在客户端上 //send(sockConn,sendInfo,strlen(sendInfo)+1,0); //从客户端接收数据，结果显示在服务器上 char recvInfo[100]; recv(sockConn,recvInfo,100,0); sprintf(c_info.name,recvInfo); printf("欢迎%s进入聊天室\n",recvInfo); sprintf(sendInfo,"欢迎%s进入聊天室\n",recvInfo); sendmessage(sendInfo); while(1) &#123; if(recv(sockConn,recvInfo,100,0)&lt;0) break; printf("[%s]:%s\n",c_info.name,recvInfo); sprintf(sendInfo,"[%s]:%s\n",c_info.name,recvInfo); sendmessage(sendInfo); &#125; //将本次建立连接中得到套接字关闭 closesocket(sockConn); return 0;&#125;void main()&#123; //加载套接字（winsock）库，加载这段代码拷贝于MSDN中WSAStartup的介绍 WORD wVersionRequested; WSADATA wsaData; int err; wVersionRequested = MAKEWORD( 1, 1 ); //版本号为1.1 err = WSAStartup( wVersionRequested, &amp;wsaData ); if ( err != 0 ) &#123; return; &#125; if ( LOBYTE( wsaData.wVersion ) != 1 || HIBYTE( wsaData.wVersion ) != 1 ) &#123; WSACleanup( ); return; &#125; //消息存储及发送 //---------------------------------------------------- //创建套接字 SOCKET sockServer=socket(AF_INET,SOCK_STREAM,0); //SOCK_STREAM参数设置为TCP连接 SOCKADDR_IN addrServer; //设置服务器端套接字的相关属性 addrServer.sin_addr.S_un.S_addr=htonl(INADDR_ANY); //设置IP addrServer.sin_family=AF_INET; addrServer.sin_port=htons(SERVER_PORP); //设置端口号 //将套接字绑定到本地地址和指定端口上 bind(sockServer,(SOCKADDR*)&amp;addrServer,sizeof(SOCKADDR)); //将套接字设置为监听模式，并将最大请求连接数设置成5，超过此数的请求全部作废 listen(sockServer,5); SOCKADDR_IN addrClient; //用来接收客户端的设置，包括IP和端口 int len=sizeof(SOCKADDR); while(1) //不断监听 &#123; //得到创建连接后的一个新的套接字，用来和客户端进行沟通，原套接字继续监听客户的连接请求 SOCKET sockConn=accept(sockServer,(SOCKADDR*)&amp;addrClient,&amp;len); if(sockConn!=INVALID_SOCKET) //创建成功 &#123; c_info_num++; C_info[c_info_num].num=c_info_num; C_info[c_info_num].sockConn=sockConn; CreateThread(NULL, 0, ThreadFun, (void *)&amp;C_info[c_info_num], 0, NULL); &#125; else &#123; int errCode=WSAGetLastError(); printf("the errcode is:%d\n",errCode); &#125; &#125; //如果本程序不是死循环，那么在此处还应添加以下代码： closesocket(sockServer); //对一直处于监听状态的套接字进行关闭 WSACleanup(); //终止对winsocket库的使用&#125; 未完成的问题用户离线时出现问题 全部代码:https://github.com/summerIwinter]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>TCP</tag>
        <tag>聊天室</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C实现简单TCP通信]]></title>
    <url>%2F2017%2F09%2F05%2FC%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95TCP%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[在VC6++下编程代码用到了其他的lib库,需要添加工程—&gt;设置—&gt;Link—&gt;library modules添加ws2_32.lib(与其他lib用空格隔开) 服务器端代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include"winsock2.h"#include "stdio.h"#define SERVER_PORP 8884//服务器端口号void main()&#123; //加载套接字（winsock）库， //加载这段代码拷贝于MSDN中WSAStartup的介绍 WORD wVersionRequested; WSADATA wsaData; int err; wVersionRequested = MAKEWORD( 1, 1 ); //版本号为1.1 err = WSAStartup( wVersionRequested, &amp;wsaData ); if ( err != 0 ) &#123; return; &#125; if ( LOBYTE( wsaData.wVersion ) != 1 || HIBYTE( wsaData.wVersion ) != 1 ) &#123; WSACleanup( ); return; &#125; //创建套接字 SOCKET sockServer=socket(AF_INET,SOCK_STREAM,0); //AF_INET指协议簇 //SOCK_STREAM参数设置为TCP连接 SOCKADDR_IN addrServer; //设置服务器端套接字的相关属性 addrServer.sin_addr.S_un.S_addr=htonl(INADDR_ANY); //设置IP addrServer.sin_family=AF_INET; addrServer.sin_port=htons(SERVER_PORP); //设置端口号 //将套接字绑定到本地地址和指定端口上 bind(sockServer,(SOCKADDR*)&amp;addrServer,sizeof(SOCKADDR)); //将套接字设置为监听模式，并将最大请求连接数设置成5，超过此数的请求全部作废 listen(sockServer,5); SOCKADDR_IN addrClient; //用来接收客户端的设置，包括IP和端口 int len=sizeof(SOCKADDR); while(1) //不断监听 &#123; //得到创建连接后的一个新的套接字，用来和客户端进行沟通，原套接字继续监听客户的连接请求 SOCKET sockConn=accept(sockServer,(SOCKADDR*)&amp;addrClient,&amp;len); if(sockConn!=INVALID_SOCKET) //创建成功 &#123; char sendInfo[100]; //inet_ntoa将结构转换为十进制的IP地址字符串 sprintf(sendInfo,"welcome %s to this Server!",inet_ntoa(addrClient.sin_addr)); //成功建立连接后向客户端发送数据，结果将显示在客户端上 send(sockConn,sendInfo,strlen(sendInfo)+1,0); //从客户端接收数据，结果显示在服务器上 char recvInfo[100]; recv(sockConn,recvInfo,100,0); printf("%s\n",recvInfo); while(1) &#123; if(recv(sockConn,recvInfo,100,0)&lt;0) break; //客户端断开recv返回负值 printf("%s\n",recvInfo); sprintf(sendInfo,recvInfo); send(sockConn,sendInfo,strlen(sendInfo)+1,0); sprintf(sendInfo,"\nsever receive this text!\n"); send(sockConn,sendInfo,strlen(sendInfo)+1,0); &#125; //将本次建立连接中得到套接字关闭 closesocket(sockConn); &#125; else &#123; int errCode=WSAGetLastError(); printf("the errcode is:%d\n",errCode); &#125; &#125; //如果本程序不是死循环，那么在此处还应添加以下代码： closesocket(sockServer); //对一直处于监听状态的套接字进行关闭 WSACleanup(); //终止对winsocket库的使用&#125; 客户端代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include "winsock2.h"#include "stdio.h"#define SERVER_IP "127.0.0.1" //服务器IP地址#define SERVER_PORP 8884 //服务器端口号void main()&#123; //加载套接字库 WORD wVersionRequested; WSADATA wsaData; int err; wVersionRequested = MAKEWORD( 1, 1 ); //版本好为1.1 err = WSAStartup( wVersionRequested, &amp;wsaData ); if ( err != 0 ) &#123; return; &#125; if ( LOBYTE( wsaData.wVersion ) != 1 || HIBYTE( wsaData.wVersion ) != 1 ) &#123; WSACleanup( ); return; &#125; SOCKET sockClient=socket(AF_INET,SOCK_STREAM,0); //SOCK_STREAM参数设置为TCP连接 SOCKADDR_IN addrServer; //服务器地址结构 addrServer.sin_addr.S_un.S_addr=inet_addr(SERVER_IP); //服务器地址 addrServer.sin_port=htons(SERVER_PORP); //服务器端口号 addrServer.sin_family=AF_INET; //与服务器端建立连接，进行通信 int connReult=connect(sockClient,(SOCKADDR*)&amp;addrServer,sizeof(SOCKADDR)); if(connReult!=WSAEADDRNOTAVAIL) //访问成功 &#123; //成功建立连接后向服务器端发送数据，结果将显示在服务器端上 char sendInfo[100]; send(sockClient,"this is zhangsan!",strlen("this is zhangsan!")+1,0); //接收来自服务器端发送来的信息 char recvInfo[100]; recv(sockClient,recvInfo,100,0); printf("%s\n",recvInfo); while(1) &#123; scanf("%s",sendInfo); send(sockClient,sendInfo,strlen(sendInfo)+1,0); recv(sockClient,recvInfo,100,0); printf("%s",recvInfo); recv(sockClient,recvInfo,100,0); printf("%s",recvInfo); &#125; &#125; else &#123; int errCode=WSAGetLastError(); printf("the errcode is:%d\n",errCode); &#125; closesocket(sockClient); WSACleanup();&#125; 客户端和服务器应分别属于两个项目先运行服务器，后运行客户端]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>TCP</tag>
        <tag>套接字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言多线程学习(VC6++环境)]]></title>
    <url>%2F2017%2F09%2F04%2FC%E8%AF%AD%E8%A8%80%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1.简单的创建多线程实例1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;windows.h&gt;//子线程函数DWORD WINAPI ThreadFun(LPVOID pM)&#123; printf("子线程的线程ID号为：%d\n子线程输出 Hello World\n", GetCurrentThreadId()); return 0;&#125;//主函数，所谓主函数其实就是主线程执行的函数。int main()&#123; printf("最简单的创建多线程实例\n"); printf("http://zfblog.xyz"); HANDLE handle = CreateThread(NULL, 0, ThreadFun, NULL, 0, NULL); WaitForSingleObject(handle, INFINITE); return 0;&#125; 使用CreateThread函数创建线程1234567HANDLE WINAPI CreateThread( LPSECURITY_ATTRIBUTES lpThreadAttributes, DWORD dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); 第一个参数表示线程内核对象的安全属性,一般传入NULL表示使用默认设置第二个参数表示线程栈空间大小,传入0表示使用默认大小(1MB)第三个参数表示新线程所执行的线程函数地址 多个线程可以使用同一个函数地址(线程函数入口)第四个参数是传给线程函数的参数第五个参数指定额外的标志来控制线程的创建 就是控制线程何时运行 为0:直接运行 为CREATE_SUSPENDED:调用ResumeThread()后运行第六个参数将返回线程的ID号,传入NULL表示不需要返回该线程ID号函数返回值:成功返回新线程的句柄,失败返回NULL2.关于CreateThread()该线程函数传递参数的问题1234567891011//创建线程时传递参数int *parameter;CreateThread(NULL, 0, ThreadFun, (void *)parameter, 0, NULL);//parameter是任意类型的地址//线程函数中调用参数DWORD WINAPI ThreadFun(LPVOID pM)&#123; //传入的地址指向一个int类型的数据 int p=*PM; return 0;&#125; WaitForSingleObject函数作用1234DWORD WINAPI WaitForSingleObject( HANDLE hHandle, DWORD dwMilliseconds); 第一个参数为要等待的内核对象第二个参数为最长等待的时间 为5000:等待5秒 为0:立即执行 为INFINITE:无限等待函数返回值:WAIT_OBJECT_0在指定的时间内对象被触发 WAIT_TIMEOUT超过最长等待时间对象仍未被触发 WAIT_FAILED传入参数有错误 函数作用首先要知道—-线程的句柄在线程运行时是未触发的，结束后触发在主函数中调用等待线程执行完毕，然后主函数结束不用此函数可能会导致线程没有执行完，主函数结束，程序结束]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows系统盘瘦身]]></title>
    <url>%2F2017%2F09%2F02%2Fwindows%E7%B3%BB%E7%BB%9F%E7%9B%98%E7%98%A6%E8%BA%AB%2F</url>
    <content type="text"><![CDATA[1.关闭系统休眠功能，删除Hiberfil.sys文件管理员运行cmd输入下面命令powercfg -h of2.设置虚拟内存控制面板—&gt;(系统和安全)—&gt;系统—&gt;高级系统设置—&gt;(高级)—&gt;设置—&gt;(高级)—&gt;更改把虚拟内存设置到其它盘3.删除临时文件以下三个目录里的文件是临时文件，可以删除C:\windows\tempC:\ProgramData\TEMPC:\Users\你的用户名\AppData\Local\Temp]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[powershell脚本遍历目录]]></title>
    <url>%2F2017%2F09%2F01%2Fpowershell%E8%84%9A%E6%9C%AC%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[遍历目录及子目录,显示目录大小12345678910111213141516function filesize ([string]$filepath) &#123; if ($filepath -eq $null) &#123; throw &quot;路径不能为空&quot; &#125; dir -Path $filepath | ForEach-Object -Process &#123; if ($_.psiscontainer -eq $true) &#123; $length = 0 dir -Path $_.fullname -Recurse | ForEach-Object &#123; $length += $_.Length &#125; $l = $length / 1KB $_.name + &quot;文件夹的大小为: &#123;0:n1&#125; KB&quot; -f $l &#125; &#125;&#125;filesize -filepath &quot;D:\&quot; 运行示例:12345678910111213141516171819202122PS F:\python&gt; function filesize ([string]$filepath) &#123;&gt;&gt; if ($filepath -eq $null) &#123;&gt;&gt; throw &quot;路径不能为空&quot;&gt;&gt; &#125;&gt;&gt; dir -Path $filepath | ForEach-Object -Process &#123;&gt;&gt; if ($_.psiscontainer -eq $true) &#123;&gt;&gt; $length = 0&gt;&gt; dir -Path $_.fullname -Recurse | ForEach-Object &#123;&gt;&gt; $length += $_.Length&gt;&gt; &#125;&gt;&gt; $l = $length / 1KB&gt;&gt; $_.name + &quot;文件夹的大小为: &#123;0:n1&#125; KB&quot; -f $l&gt;&gt; &#125;&gt;&gt; &#125;&gt;&gt; &#125;PS F:\python&gt; filesize -filepath &quot;f:\python&quot;ipluyou文件夹的大小为: 82,196.5 KBloginip_jlu文件夹的大小为: 16.8 KB嗅事百科文件夹的大小为: 4.3 KB小说文件夹的大小为: 31,043.6 KB笑料文件夹的大小为: 1,578,575.8 KBPS F:\python&gt;]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>powershell</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[powershell卸载自带应用]]></title>
    <url>%2F2017%2F09%2F01%2Fpowershell%E5%8D%B8%E8%BD%BD%E8%87%AA%E5%B8%A6%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[卸载全部自带应用Get-AppxPackage -User $env:USERNAME | Remove-AppxPackage其他更多卸载OneNote:Get-AppxPackage OneNote | Remove-AppxPackage3D:Get-AppxPackage 3d | Remove-AppxPackageCamera相机:Get-AppxPackage camera | Remove-AppxPackage邮件和日历:Get-AppxPackage communi | Remove-AppxPackage新闻订阅:Get-AppxPackage bing | Remove-AppxPackageGroove音乐电影与电视:Get-AppxPackage zune | Remove-AppxPackage人脉:Get-AppxPackage people | Remove-AppxPackage手机伴侣Phone Companion:Get-AppxPackage phone | Remove-AppxPackage照片:Get-AppxPackage photo | Remove-AppxPackage纸牌游戏(还敢要钱的那货):Get-AppxPackage solit | Remove-AppxPackage录音机:Get-AppxPackage soundrec | Remove-AppxPackageXbox:Get-AppxPackage xbox | Remove-AppxPackage]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>powershell</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己写一个Android照相机应用-2]]></title>
    <url>%2F2017%2F08%2F19%2F%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AAAndroid%E7%85%A7%E7%9B%B8%E6%9C%BA%E5%BA%94%E7%94%A8-2%2F</url>
    <content type="text"><![CDATA[自定义相机首先是要创建camera的生命周期123getCamera();//获取Camera对象setStartPreview(Camera camera,SurfaceHolder holder);//预览相机内容releaseCamera();//释放相机资源 activity生命周期与camera绑定12345678910111213protected void onResume() &#123; super.onResume(); if (mCamera == null) &#123; mCamera = getCamera(); if (mHolder != null) &#123; setStartPreview(mCamera,mHolder); &#125; &#125;&#125;protected void onPause() &#123; super.onPause(); releaseCamera();&#125; camera与surfaceview绑定12345678910111213141516//预览图像与camera绑定@Overridepublic void surfaceCreated(SurfaceHolder holder) &#123; setStartPreview(mCamera,mHolder);&#125;@Overridepublic void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; mCamera.stopPreview(); setStartPreview(mCamera,mHolder);&#125;@Overridepublic void surfaceDestroyed(SurfaceHolder holder) &#123; releaseCamera();&#125; 声明相机使用权限1&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;&lt;/uses-permission&gt; 实现照相，通过回调将照片数据保存到文件，并将文件路径传递到其它activity(ResultAty)12345678910111213141516171819202122232425262728293031323334private Camera.PictureCallback mPictureCallback = new Camera.PictureCallback() &#123; @Override public void onPictureTaken(byte[] data, Camera camera) &#123;//data中存储照片的全部信息 File tempFile = new File("/sdacrd/temp.png"); try &#123; FileOutputStream fos = new FileOutputStream(tempFile); fos.write(data); fos.close(); Intent intent = new Intent(CustomCamera.this,ResultAty.class); intent.putExtra("picPath",tempFile.getAbsolutePath()); startActivity(intent); CustomCamera.this.finish(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;;public void capture(View view)&#123; Camera.Parameters parameters = mCamera.getParameters(); parameters.setPictureFormat(ImageFormat.JPEG);//设置拍照格式jpg格式 parameters.setPictureSize(800,400);//设置照片大小 parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);//设置自动对焦 mCamera.autoFocus(new Camera.AutoFocusCallback() &#123; //回调，对焦最清晰时拍照 @Override public void onAutoFocus(boolean success, Camera camera) &#123; if (success) &#123; mCamera.takePicture(null,null,mPictureCallback); &#125; &#125; &#125;);&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>相机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA套接字之TCP实现聊天室]]></title>
    <url>%2F2017%2F08%2F10%2FJAVA%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B9%8BTCP%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[java实现聊天室通过多线程实现随时加入，随时退出 客户端程序客户端有两个线程一个线程由主类SocketClient实现向服务器发送消息一个线程由内部类readLineThread实现监听服务器发来的消息并显示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;public class SocketClient extends Socket&#123; private static final String SERVER_IP = "127.0.0.1"; private static final int SERVER_PORT = 2017; private Socket client; private PrintWriter out; private BufferedReader in; /** * 与服务器连接，并输入发送消息 */ public SocketClient() throws Exception&#123; super(SERVER_IP, SERVER_PORT); client = this; out = new PrintWriter(this.getOutputStream(), true); in = new BufferedReader(new InputStreamReader(this.getInputStream())); new readLineThread(); while(true)&#123; in = new BufferedReader(new InputStreamReader(System.in)); String input = in.readLine(); out.println(input); &#125; &#125; /** * 用于监听服务器端向客户端发送消息线程类 */ class readLineThread extends Thread&#123; private BufferedReader buff; public readLineThread()&#123; try &#123; buff = new BufferedReader(new InputStreamReader(client.getInputStream())); start(); &#125; catch (Exception e) &#123; &#125; &#125; @Override public void run() &#123; try &#123; while(true)&#123; String result = buff.readLine(); if("byeClient".equals(result))&#123;//客户端申请退出，服务端返回确认退出 break; &#125;else&#123;//输出服务端发送消息 System.out.println(result); &#125; &#125; in.close(); out.close(); client.close(); &#125; catch (Exception e) &#123; &#125; &#125; &#125; public static void main(String[] args) &#123; try &#123; new SocketClient();//启动客户端 &#125; catch (Exception e) &#123; &#125; &#125;&#125; 服务器程序服务器由三个类实现主类Server监听客户端请求，并启用线程处理请求内部类PrintOutThread监听输出消息请求，将消息发送到所有客户端内部类ServerThread提供与每一个用户的连接123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;import java.util.ArrayList;import java.util.LinkedList;import java.util.List;public class Server extends ServerSocket &#123; private static final int SERVER_PORT = 2017; private static boolean isPrint = false;// 是否输出消息标志 private static List user_list = new ArrayList();// 登录用户集合 private static List&lt;ServerThread&gt; thread_list = new ArrayList&lt;ServerThread&gt;();// 服务器已启用线程集合 private static LinkedList message_list = new LinkedList();// 存放消息队列 /** * 创建服务端Socket,创建向客户端发送消息线程,监听客户端请求并处理 */ public Server() throws IOException &#123; super(SERVER_PORT);// 创建ServerSocket new PrintOutThread();// 创建向客户端发送消息线程 try &#123; while (true) &#123;// 监听客户端请求，启用一个线程处理 Socket socket = accept(); new ServerThread(socket); &#125; &#125; catch (Exception e) &#123; &#125; finally &#123; close(); &#125; &#125; /** * 监听是否有输出消息请求线程类,向客户端发送消息 */ class PrintOutThread extends Thread &#123; public PrintOutThread() &#123; start(); &#125; @Override public void run() &#123; while (true) &#123; //没有打印这句，if里面的语句不会执行，可能是多线程访问isPrint造成的 System.out.println("运行中。。。"+isPrint); if (isPrint) &#123;// 将缓存在队列中的消息按顺序发送到各客户端,并从队列中清除。 String message = (String) message_list.getFirst(); for (ServerThread thread : thread_list) &#123; thread.sendMessage(message); &#125; message_list.removeFirst(); isPrint = message_list.size() &gt; 0 ? true : false; &#125; &#125; &#125; &#125; /** * 服务器线程类 */ @SuppressWarnings("unchecked") class ServerThread extends Thread &#123; private Socket client; private PrintWriter out; private BufferedReader in; private String name; public ServerThread(Socket s) throws IOException &#123; client = s; out = new PrintWriter(client.getOutputStream(), true); in = new BufferedReader(new InputStreamReader(client.getInputStream())); //in.readLine(); out.println("成功连上聊天室,请输入你的名字："); start(); &#125; @Override public void run() &#123; try &#123; int flag = 0; String line = in.readLine(); while (true) &#123; // 查看在线用户列表 if ("showuser".equals(line)) &#123; out.println(this.listOnlineUsers()); &#125; if("bye".equals(line))&#123; out.println("bye"); break;&#125; // 第一次进入，保存名字 if (flag++ == 0) &#123; name = line; user_list.add(name); thread_list.add(this); out.println(name + "你好,可以开始聊天了..."); this.pushMessage("Client&lt;" + name + "&gt;进入聊天室..."); &#125; else &#123; this.pushMessage("Client&lt;" + name + "&gt; say : " + line); &#125; line = in.readLine(); &#125; out.println("byeClient"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123;// 用户退出聊天室 try &#123; client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; thread_list.remove(this); user_list.remove(name); pushMessage("Client&lt;" + name + "&gt;退出了聊天室"); &#125; &#125; // 放入消息队列末尾，准备发送给客户端 private void pushMessage(String msg) &#123; message_list.addLast(msg); isPrint = true; &#125; // 向客户端发送一条消息 private void sendMessage(String msg) &#123; out.println(msg); &#125; // 统计在线用户列表 private String listOnlineUsers() &#123; String s = "--- 在线用户列表 ---\015\012"; for (int i = 0; i &lt; user_list.size(); i++) &#123; s += "[" + user_list.get(i) + "]\015\012"; &#125; s += "--------------------"; return s; &#125; &#125; public static void main(String[] args) throws IOException &#123; new Server();// 启动服务端 &#125;&#125; 这里好像出现了多线程问题123456789101112131415@Overridepublic void run() &#123; while (true) &#123; //没有打印下面这句，if里面的语句不会执行，可能是多线程访问isPrint造成的 System.out.println("运行中。。。"+isPrint); if (isPrint) &#123;// 将缓存在队列中的消息按顺序发送到各客户端，并从队列中清除。 String message = (String) message_list.getFirst(); for (ServerThread thread : thread_list) &#123; thread.sendMessage(message); &#125; message_list.removeFirst(); isPrint = message_list.size() &gt; 0 ? true : false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>TCP</tag>
        <tag>聊天室</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA套接字之TCP简单实用]]></title>
    <url>%2F2017%2F08%2F09%2FJAVA%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B9%8BTCP%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1,单客户端排队与服务器建立连接 客户端程序123456789101112131415161718192021222324252627import java.net.*;import java.io.*;public class Client&#123; static Socket server; public static void main(String[] args)throws Exception&#123; //客户端请求与本机在5678端口建立TCP连接 server=new Socket(InetAddress.getLocalHost(),5678); BufferedReader in= new BufferedReader(new InputStreamReader(server.getInputStream())); //获取Socket的输入流，用来接收从服务端发送过来的数据 PrintWriter out=new PrintWriter(server.getOutputStream()); //获取Socket的输出流，用来发送数据到服务端 BufferedReader wt=new BufferedReader(new InputStreamReader(System.in)); //从键盘输入的数据流 while(true)&#123; String str=wt.readLine();//读取键盘输入字符串 out.println(str);//发送数据到服务端 out.flush(); if(str.equals("end"))&#123; break; &#125; System.out.println(in.readLine());//打印服务器返回的字符串 &#125; server.close();//关闭连接 &#125;&#125; 服务器程序11234567891011121314151617181920212223import java.io.*;import java.net.*;public class Server &#123; public static void main(String[] args) throws IOException&#123; ServerSocket server=new ServerSocket(5678);//通信端口 while(true)&#123;//一个客户端断开连接后，等待与另一个客户端建立连接 Socket client=server.accept();//accept用于产生"阻塞"，直到接受到一个连接，并且返回一个客户端的Socket对象实例。 BufferedReader in= new BufferedReader(new InputStreamReader(client.getInputStream())); PrintWriter out=new PrintWriter(client.getOutputStream()); while(true)&#123;//直到客户端发送end退出循环 String str=in.readLine(); System.out.println(str); out.println("has receive...."); out.flush(); if(str.equals("end")) break; &#125; client.close();//关闭通信 &#125; &#125; &#125; 2,多个客户端同时与服务器建立连接客户端程序不变,服务器端阻塞等待客户端连接,并给每个链接分配一个线程 服务器程序212345678910111213141516171819202122232425262728293031323334353637import java.io.*;import java.net.*;public class Server extends Thread &#123;//继承Thread类 private Socket client; public Server(Socket c)&#123;//类初始化，接受参数为客户端的请求 this.client = c; &#125; public void run()&#123;//重写run函数 try&#123; BufferedReader in= new BufferedReader(new InputStreamReader(client.getInputStream())); PrintWriter out=new PrintWriter(client.getOutputStream()); while(true)&#123; String str=in.readLine(); System.out.println(str); out.println("has receive...."); out.flush(); if(str.equals("end")) break; &#125; client.close(); &#125;catch(IOException ex)&#123; &#125;finally&#123; &#125; &#125; public static void main(String[] args) throws IOException&#123; ServerSocket server=new ServerSocket(5678); while(true)&#123; Server mu=new Server(server.accept());//每当有客户端请求就新建一个Server类与之通信 mu.start();//启动进程 &#125; &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己写一个Android照相机应用-1]]></title>
    <url>%2F2017%2F08%2F09%2F%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AAAndroid%E7%85%A7%E7%9B%B8%E6%9C%BA%E5%BA%94%E7%94%A8-1%2F</url>
    <content type="text"><![CDATA[Android Camera相关知识调用系统相机12345678910111213Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);//使用action启动系统相机//startActivity(intent); //仅调用相机拍照，不返回数据//startActivityForResult(intent,REQ_1);//调用相机并通过onActivityResult函数data返回数据；Uri photoUri = Uri.fromFile(new File(mFilePath));//图片保存路径intent.putExtra(MediaStore.EXTRA_OUTPUT,photoUri);startActivityForResult(intent,REQ_2);//从文件中读取数据 路径获取12&lt;pre class=&quot;hljs undefined&quot;&gt;`mFilePath = Environment.getExternalStorageDirectory().getPath();mFilePath = mFilePath + &quot;/&quot; + &quot;tmp.png&quot;; 读取内存卡权限1&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt; onActivityResult函数12345678910111213141516171819202122232425protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if(resultCode == RESULT_OK)&#123; if (requestCode == REQ_1) &#123;//从data获取照片 Bundle bundle = data.getExtras(); Bitmap bitmap = (Bitmap)bundle.get("data"); mImageView.setImageBitmap(bitmap); &#125; else if (requestCode == REQ_2) &#123;//从文件获取照片 FileInputStream fis = null; try &#123; fis = new FileInputStream(mFilePath); Bitmap bitmap = BitmapFactory.decodeStream(fis); mImageView.setImageBitmap(bitmap); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; 注册action，实现照相功能1234&lt;intent-filter&gt; &lt;action android:name=&quot;android.media.action.IMAGE_CAPTURE&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;&lt;/intent-filter&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>相机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab函数freqs和freqz]]></title>
    <url>%2F2017%2F08%2F09%2FMatlab%E5%87%BD%E6%95%B0freqs%E5%92%8Cfreqz%2F</url>
    <content type="text"><![CDATA[1,freqs模拟滤波器的频率响应语法：1234h = freqs(b,a,w)[h,w] = freqs(b,a)[h,w] = freqs(b,a,f)freqs(b,a) 描述：freqs 返回一个模拟滤波器的H(jw)的复频域响应（拉普拉斯格式） h = freqs(b, a, w) 根据系数向量计算返回模拟滤波器的复频域响应freqs 计算在复平面虚轴上的频率响应h，角频率w确定了输入的实向量，因此必须包含至少一个频率点。[h, w] = freqs(b, a) 自动挑选200个频率点来计算频率响应h[h, w] = freqs(b, a, f) 挑选f个频率点来计算频率响应h例子：找到并画出下面传递函数的频率响应 Matlab代码：1234a = [1 0.4 1];b = [0.2 0.3 1];w = logspace(-1, 1);freqs(b, a, w); logspace 功能：生成从10的a次方到10的b次方之间按对数等分的n个元素的行向量n如果省略，则默认值为50。12345h=freqs(b,a,w);mag = abs(h);phase = angle(h);subplot(2,1,1), loglog(w,mag);subplot(2,1,2), semilogx(w,phase);f = w/(2*pi);mag = 20*log10(mag);phase = phase*180/pi; 2,freqzMATLAB提供了专门用于求离散系统频响特性的函数freqz()调用freqz()的格式有以下两种：(1):[H,w]=freqz(B,A,N) B和A分别为离散系统的系统函数分子、分母多项式的系数向量，N为正整数，返回量H则包含了离散系统频响 在 0——pi范围内N个频率等分点的值，向量w则包含 范围内N个频率等分点。调用中若N默认，默认值为512。(2):[H,w]=freqz(B,A,N,’whole’)该调用格式将计算离散系统在0—pi范内的N个频率等分店的频率响应的值。因此，可以先调用freqz()函数计算系统的频率响应，然后利用abs()和angle()函数及plot()函数，即可绘制出系统在 或 范围内的频响曲线。例：绘制如下系统的频响曲线H(z)=(z-0.5)/zMATLAB命令如下：123B=[1 -0.5];A =[1 0];[H,w]=freqz(B,A,400,'whole'); H是频率响应的幅度，w是0–pi内的400个点123456789Hf=abs(H);Hx=angle(H);clffigure(1)plot(w,Hf)title('离散系统幅频特性曲线')figure(2)plot(w,Hx)title('离散系统相频特性曲线') 幅频特性.PNG 相频特性.PNG这样画出来的是线性的，要想获得db格式的幅度，需要转换 20*log10（Hf）之后再画就是db格式的也可以直接用freqz(b,a,w)这样就会画出幅频响应和相频响应，幅频响应直接是db格式的幅度。]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
        <tag>freqs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyQt5]]></title>
    <url>%2F2017%2F08%2F09%2FPyQt5%2F</url>
    <content type="text"><![CDATA[安装1pip install python-qt5 把ui转py1python -m PyQt5.uic.pyuic &lt;arguments&gt; lineEdit输入隐藏，密码1lineEdit.setEchoMode(QtWidgets.QLineEdit.Password) py转exe12pip install pyinstallerpyinstaller demo.py 参数 含义 -F 指定打包后只生成一个exe格式的文件 -D –onedir创建一个目录,包含exe文件,但会依赖很多文件（默认选项） -c –console,–nowindowed使用控制台,无界面(默认) -w –windowed,–noconsole使用窗口,无控制台 -p 添加搜索路径,让其找到对应的库。 -i 改变生成程序的icon图标]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>PyQt5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搬瓦工VPS搭建Web服务器]]></title>
    <url>%2F2017%2F08%2F04%2F%E6%90%AC%E7%93%A6%E5%B7%A5VPS%E6%90%AD%E5%BB%BAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在centos上安装apache+php+mysql的过程搬瓦工VPS购买地址 安装apache安装yum install httpd 启动service httpd start暂停service httpd stop重启service httpd restart 检查开机启动情况chkconfig --list httpd默认情况下是全部关闭的，尽量设置开机启动，以防主机意外关机 设置开机启动命令chkconfig httpd on再次检查启动情况，看到2，3，4，5为启动关闭开机启动命令chkconfig httpd off 到此Apache安装完成，在自己浏览器中输入主机IP和端口号能正常打开 安装php命令为123yum install phpyum install php-mysql php-gd php-imap php-ldap php-odbc php-pear php-xml php-xmlrpcyum install php-mysql 以上命令为安装php及其支持的组件 安装mysql##安装首先查看主机是否已经安装rpm -qa|grep mysql 注意：可能检查中安装有php-mysql XXXXX 和 mysql-libXXXX,这是刚刚第二步安装的php的组件,不必理会 已经安装的话就执行删除命令rmp -e mysql 然后继续安装使用命令yum list | grep mysql来查看yum上提供的mysql数据库可下载的版本 安装命令yum install -y mysql-server mysql mysql-devel等待一段时间安装成功 ##配置接下来是对mysql的配置(注意:命令中是”mysqld”,不是mysql) 初始化:service mysqld start重启:service mysqld restart配置开机自动启动:chkconfig mysqld on 为mysql的root账户设置密码:mysqladmin -u root password &#39;*********&#39;登录命令mysql -u root -p]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>php</tag>
        <tag>mysql</tag>
        <tag>web</tag>
        <tag>服务器</tag>
        <tag>centos</tag>
        <tag>搬瓦工</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python2与Python3共存]]></title>
    <url>%2F2017%2F08%2F03%2FPython2%E4%B8%8EPython3%E5%85%B1%E5%AD%98%2F</url>
    <content type="text"><![CDATA[安装两个版本的Pythonpython2下载地址:https://www.python.org/ftp/python/2.7.13/python-2.7.13.msipython3下载地址:https://www.python.org/ftp/python/3.6.2/python-3.6.2.exe进行安装(安装顺序随便) 尽量安装到同一目录下的两个文件夹例如:python2安装在”D:\program\python27\”下python3安装在”D:\program\python36\”下 添加环境变量Path中要有一下四个路径1234D:\program\python\Python36\Scripts\D:\program\python\Python36\D:\program\python\python27\ScriptsD:\program\python\python27\ 更改python.exe名字找到找到两个python的安装目录D:\program\python\Python36\python.exe更改为D:\program\python\Python36\python3.exeD:\program\python\Python27\python.exe更改为D:\program\python\Python36\python2.exe 此时两个版本的python已经共同存在但还要对pip进行修改 更改pip名称重装python2和python3的pip12python2 -m pip install --upgrade pip --force-reinstallpython3 -m pip install --upgrade pip --force-reinstall 重装成功后进行如下测试可见python2和python3已经共存pip的问题也解决了但直接调用pip是还能执行并且是后安装的pip的版本python命令已经不存在直接运行py结尾的文件时会出现问题python自带的编辑器出现了两个]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搬瓦工安装ss并加速]]></title>
    <url>%2F2017%2F08%2F03%2F%E6%90%AC%E7%93%A6%E5%B7%A5%E5%AE%89%E8%A3%85ss%E5%B9%B6%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[搬瓦工（BandwagonHost）是美国IT7公司旗下的一家提供便宜年付OVZ架构的VPS主机方案的服务商。价格便宜、且依托的商家比较靠谱，具有较高的性价比。拿来搭个FQ是非常合适的，做个小站也是可以的。 1.购买地址 搬瓦工所有配置及购买地址:https://bandwagonhost.com/aff.php?aff=17697以前有小内存的VPS年费三刀，很便宜，但现在没有了，缺货，连521M的有时候也会缺货，看来挺火的。 2.安装Shadowsocks2.1搬瓦工后台一键安装(不推荐)登录账号-&gt;Client Area-&gt;Services-&gt;My Services-&gt;KiwiVM Control Panel来到管理面板，点击 Shadowsocks Server 就可以一键安装 Shadowsocks测试过它自带的一键安装，速度太慢，yotube视频看不了，有点慢。 2.2使用shell脚本安装(推荐)2.2.1安装 shadowsoksRShadowsocks的一个分支，比较不错。但是默认是 aes-256-cfb 加密，如果需要 chacha20 加密，需要手动切换。123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log 安装成功需要等几分钟这个速度可以看yotube无压力 卸载方法：使用 root 用户登录，运行以下命令：1./shadowsocksR.sh uninstall 安装完成后即已后台启动 ShadowsocksR,运行：1/etc/init.d/shadowsocks status 可以查看 ShadowsocksR 进程是否已经启动。本脚本安装完成后，已将 ShadowsocksR 自动加入开机自启动。 其它命令：启动：/etc/init.d/shadowsocks start停止：/etc/init.d/shadowsocks stop重启：/etc/init.d/shadowsocks restart状态：/etc/init.d/shadowsocks status 配置文件路径：/etc/shadowsocks.json日志文件路径：/var/log/shadowsocks.log代码安装目录：/usr/local/shadowsocks 2.2.1安装 shadowsocks-go版本据说有buff，比python版Shadowsocks要快：123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-go.shchmod +x shadowsocks-go.sh./shadowsocks-go.sh 2&amp;gt;&amp;amp;1 | tee shadowsocks-go.log 2.2.3其他版本Shadowsocks一键安装：来自 teddysun：https://github.com/teddysun/shadowsocks_install 3.遇到的一些问题3.1搬瓦工默认系统Centos没有wget命令需要安装安装命令:1yum -y install wget 3.2关于配置多用户1vi /etc/shadowsocks.json 只需要在port_password项下添加”端口号”:”密码”1234567891011121314151617181920&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_ipv6&quot;:&quot;[::]&quot;, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;:&#123; &quot;28998&quot;: &quot;123456&quot;, &quot;28989&quot;: &quot;123456&quot; &#125;, &quot;timeout&quot;:120, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;protocol&quot;:&quot;origin&quot;, &quot;protocol_param&quot;:&quot;&quot;, &quot;obfs&quot;:&quot;plain&quot;, &quot;obfs_param&quot;:&quot;&quot;, &quot;redirect&quot;:&quot;&quot;, &quot;dns_ipv6&quot;:false, &quot;fast_open&quot;:false, &quot;workers&quot;:1&#125; 参见:https://blog.kuoruan.com/48.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>搬瓦工</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA实现MD5加密]]></title>
    <url>%2F2017%2F07%2F02%2FJAVA%E5%AE%9E%E7%8E%B0MD5%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[java实现MD5加密的两种方法1,调用MessageDigest实现12345678910111213141516171819202122232425262728293031323334353637383940import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class CreatMD5 &#123; public String getMd5(String plainText)&#123; try &#123; MessageDigest md = MessageDigest.getInstance("MD5"); md.update(plainText.getBytes()); byte b[] = md.digest(); int i; StringBuffer buf = new StringBuffer(""); for (int offset = 0; offset &lt; b.length; offset++) &#123; i = b[offset]; if (i &lt; 0) i += 256; if (i &lt; 16) buf.append("0"); buf.append(Integer.toHexString(i)); &#125; //32位加密 return buf.toString(); // 16位的加密 //return buf.toString().substring(8, 24); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); return null; &#125; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub CreatMD5 md=new CreatMD5(); System.out.println(md.getMd5("hello")); &#125;&#125; 2,自己编写函数实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273public class CreateMD5i &#123; static final String hexs[]=&#123;"0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"&#125;; //标准的幻数 private static final long A=0x67452301L; private static final long B=0xefcdab89L; private static final long C=0x98badcfeL; private static final long D=0x10325476L; //下面这些S11-S44实际上是一个4*4的矩阵，在四轮循环运算中用到 static final int S11 = 7; static final int S12 = 12; static final int S13 = 17; static final int S14 = 22; static final int S21 = 5; static final int S22 = 9; static final int S23 = 14; static final int S24 = 20; static final int S31 = 4; static final int S32 = 11; static final int S33 = 16; static final int S34 = 23; static final int S41 = 6; static final int S42 = 10; static final int S43 = 15; static final int S44 = 21; //java不支持无符号的基本数据（unsigned） private long [] result=&#123;A,B,C,D&#125;;//存储hash结果，共4×32=128位，初始化值为（幻数的级联） public static void main(String []args)&#123; CreateMD5i md=new CreateMD5i(); System.out.println("md5(hello)="+md.digest("hello")); &#125; public String digest(String inputStr)&#123; byte [] inputBytes=inputStr.getBytes(); int byteLen=inputBytes.length;//长度（字节） int groupCount=0;//完整分组的个数 groupCount=byteLen/64;//每组512位（64字节） long []groups=null;//每个小组(64字节)再细分后的16个小组(4字节) //处理每一个完整 分组 for(int step=0;step&lt;groupCount;step++)&#123; groups=divGroup(inputBytes,step*64); trans(groups);//处理分组，核心算法 &#125; //处理完整分组后的尾巴 int rest=byteLen%64;//512位分组后的余数 byte [] tempBytes=new byte[64]; if(rest&lt;=56)&#123; for(int i=0;i&lt;rest;i++) tempBytes[i]=inputBytes[byteLen-rest+i]; if(rest&lt;56)&#123; tempBytes[rest]=(byte)(1&lt;&lt;7); for(int i=1;i&lt;56-rest;i++) tempBytes[rest+i]=0; &#125; long len=(long)(byteLen&lt;&lt;3); for(int i=0;i&lt;8;i++)&#123; tempBytes[56+i]=(byte)(len&amp;0xFFL); len=len&gt;&gt;8; &#125; groups=divGroup(tempBytes,0); trans(groups);//处理分组 &#125;else&#123; for(int i=0;i&lt;rest;i++) tempBytes[i]=inputBytes[byteLen-rest+i]; tempBytes[rest]=(byte)(1&lt;&lt;7); for(int i=rest+1;i&lt;64;i++) tempBytes[i]=0; groups=divGroup(tempBytes,0); trans(groups);//处理分组 for(int i=0;i&lt;56;i++) tempBytes[i]=0; long len=(long)(byteLen&lt;&lt;3); for(int i=0;i&lt;8;i++)&#123; tempBytes[56+i]=(byte)(len&amp;0xFFL); len=len&gt;&gt;8; &#125; groups=divGroup(tempBytes,0); trans(groups);//处理分组 &#125; //将Hash值转换成十六进制的字符串 String resStr=""; long temp=0; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; temp=result[i]&amp;0x0FL; String a=hexs[(int)(temp)]; result[i]=result[i]&gt;&gt;4; temp=result[i]&amp;0x0FL; resStr+=hexs[(int)(temp)]+a; result[i]=result[i]&gt;&gt;4; &#125; &#125; return resStr; &#125; /** * 从inputBytes的index开始取512位，作为新的分组 * 将每一个512位的分组再细分成16个小组，每个小组64位（8个字节） * @param inputBytes * @param index * @return */ private static long[] divGroup(byte[] inputBytes,int index)&#123; long [] temp=new long[16]; for(int i=0;i&lt;16;i++)&#123; temp[i]=b2iu(inputBytes[4*i+index])| (b2iu(inputBytes[4*i+1+index]))&lt;&lt;8| (b2iu(inputBytes[4*i+2+index]))&lt;&lt;16| (b2iu(inputBytes[4*i+3+index]))&lt;&lt;24; &#125; return temp; &#125; /** * 这时不存在符号位（符号位存储不再是代表正负），所以需要处理一下 * @param b * @return */ public static long b2iu(byte b)&#123; return b &lt; 0 ? b &amp; 0x7F + 128 : b; &#125; /** * 主要的操作，四轮循环 * @param groups[]--每一个分组512位（64字节） */ private void trans(long[] groups) &#123; long a = result[0], b = result[1], c = result[2], d = result[3]; /*第一轮*/ a = FF(a, b, c, d, groups[0], S11, 0xd76aa478L); /* 1 */ d = FF(d, a, b, c, groups[1], S12, 0xe8c7b756L); /* 2 */ c = FF(c, d, a, b, groups[2], S13, 0x242070dbL); /* 3 */ b = FF(b, c, d, a, groups[3], S14, 0xc1bdceeeL); /* 4 */ a = FF(a, b, c, d, groups[4], S11, 0xf57c0fafL); /* 5 */ d = FF(d, a, b, c, groups[5], S12, 0x4787c62aL); /* 6 */ c = FF(c, d, a, b, groups[6], S13, 0xa8304613L); /* 7 */ b = FF(b, c, d, a, groups[7], S14, 0xfd469501L); /* 8 */ a = FF(a, b, c, d, groups[8], S11, 0x698098d8L); /* 9 */ d = FF(d, a, b, c, groups[9], S12, 0x8b44f7afL); /* 10 */ c = FF(c, d, a, b, groups[10], S13, 0xffff5bb1L); /* 11 */ b = FF(b, c, d, a, groups[11], S14, 0x895cd7beL); /* 12 */ a = FF(a, b, c, d, groups[12], S11, 0x6b901122L); /* 13 */ d = FF(d, a, b, c, groups[13], S12, 0xfd987193L); /* 14 */ c = FF(c, d, a, b, groups[14], S13, 0xa679438eL); /* 15 */ b = FF(b, c, d, a, groups[15], S14, 0x49b40821L); /* 16 */ /*第二轮*/ a = GG(a, b, c, d, groups[1], S21, 0xf61e2562L); /* 17 */ d = GG(d, a, b, c, groups[6], S22, 0xc040b340L); /* 18 */ c = GG(c, d, a, b, groups[11], S23, 0x265e5a51L); /* 19 */ b = GG(b, c, d, a, groups[0], S24, 0xe9b6c7aaL); /* 20 */ a = GG(a, b, c, d, groups[5], S21, 0xd62f105dL); /* 21 */ d = GG(d, a, b, c, groups[10], S22, 0x2441453L); /* 22 */ c = GG(c, d, a, b, groups[15], S23, 0xd8a1e681L); /* 23 */ b = GG(b, c, d, a, groups[4], S24, 0xe7d3fbc8L); /* 24 */ a = GG(a, b, c, d, groups[9], S21, 0x21e1cde6L); /* 25 */ d = GG(d, a, b, c, groups[14], S22, 0xc33707d6L); /* 26 */ c = GG(c, d, a, b, groups[3], S23, 0xf4d50d87L); /* 27 */ b = GG(b, c, d, a, groups[8], S24, 0x455a14edL); /* 28 */ a = GG(a, b, c, d, groups[13], S21, 0xa9e3e905L); /* 29 */ d = GG(d, a, b, c, groups[2], S22, 0xfcefa3f8L); /* 30 */ c = GG(c, d, a, b, groups[7], S23, 0x676f02d9L); /* 31 */ b = GG(b, c, d, a, groups[12], S24, 0x8d2a4c8aL); /* 32 */ /*第三轮*/ a = HH(a, b, c, d, groups[5], S31, 0xfffa3942L); /* 33 */ d = HH(d, a, b, c, groups[8], S32, 0x8771f681L); /* 34 */ c = HH(c, d, a, b, groups[11], S33, 0x6d9d6122L); /* 35 */ b = HH(b, c, d, a, groups[14], S34, 0xfde5380cL); /* 36 */ a = HH(a, b, c, d, groups[1], S31, 0xa4beea44L); /* 37 */ d = HH(d, a, b, c, groups[4], S32, 0x4bdecfa9L); /* 38 */ c = HH(c, d, a, b, groups[7], S33, 0xf6bb4b60L); /* 39 */ b = HH(b, c, d, a, groups[10], S34, 0xbebfbc70L); /* 40 */ a = HH(a, b, c, d, groups[13], S31, 0x289b7ec6L); /* 41 */ d = HH(d, a, b, c, groups[0], S32, 0xeaa127faL); /* 42 */ c = HH(c, d, a, b, groups[3], S33, 0xd4ef3085L); /* 43 */ b = HH(b, c, d, a, groups[6], S34, 0x4881d05L); /* 44 */ a = HH(a, b, c, d, groups[9], S31, 0xd9d4d039L); /* 45 */ d = HH(d, a, b, c, groups[12], S32, 0xe6db99e5L); /* 46 */ c = HH(c, d, a, b, groups[15], S33, 0x1fa27cf8L); /* 47 */ b = HH(b, c, d, a, groups[2], S34, 0xc4ac5665L); /* 48 */ /*第四轮*/ a = II(a, b, c, d, groups[0], S41, 0xf4292244L); /* 49 */ d = II(d, a, b, c, groups[7], S42, 0x432aff97L); /* 50 */ c = II(c, d, a, b, groups[14], S43, 0xab9423a7L); /* 51 */ b = II(b, c, d, a, groups[5], S44, 0xfc93a039L); /* 52 */ a = II(a, b, c, d, groups[12], S41, 0x655b59c3L); /* 53 */ d = II(d, a, b, c, groups[3], S42, 0x8f0ccc92L); /* 54 */ c = II(c, d, a, b, groups[10], S43, 0xffeff47dL); /* 55 */ b = II(b, c, d, a, groups[1], S44, 0x85845dd1L); /* 56 */ a = II(a, b, c, d, groups[8], S41, 0x6fa87e4fL); /* 57 */ d = II(d, a, b, c, groups[15], S42, 0xfe2ce6e0L); /* 58 */ c = II(c, d, a, b, groups[6], S43, 0xa3014314L); /* 59 */ b = II(b, c, d, a, groups[13], S44, 0x4e0811a1L); /* 60 */ a = II(a, b, c, d, groups[4], S41, 0xf7537e82L); /* 61 */ d = II(d, a, b, c, groups[11], S42, 0xbd3af235L); /* 62 */ c = II(c, d, a, b, groups[2], S43, 0x2ad7d2bbL); /* 63 */ b = II(b, c, d, a, groups[9], S44, 0xeb86d391L); /* 64 */ /*加入到之前计算的结果当中*/ result[0] += a; result[1] += b; result[2] += c; result[3] += d; result[0]=result[0]&amp;0xFFFFFFFFL; result[1]=result[1]&amp;0xFFFFFFFFL; result[2]=result[2]&amp;0xFFFFFFFFL; result[3]=result[3]&amp;0xFFFFFFFFL; &#125; /** * 下面是处理要用到的线性函数 */ private static long F(long x, long y, long z) &#123; return (x &amp; y) | ((~x) &amp; z); &#125; private static long G(long x, long y, long z) &#123; return (x &amp; z) | (y &amp; (~z)); &#125; private static long H(long x, long y, long z) &#123; return x ^ y ^ z; &#125; private static long I(long x, long y, long z) &#123; return y ^ (x | (~z)); &#125; private static long FF(long a, long b, long c, long d, long x, long s, long ac) &#123; a += (F(b, c, d)&amp;0xFFFFFFFFL) + x + ac; a = ((a&amp;0xFFFFFFFFL)&lt;&lt; s) | ((a&amp;0xFFFFFFFFL) &gt;&gt;&gt; (32 - s)); a += b; return (a&amp;0xFFFFFFFFL); &#125; private static long GG(long a, long b, long c, long d, long x, long s, long ac) &#123; a += (G(b, c, d)&amp;0xFFFFFFFFL) + x + ac; a = ((a&amp;0xFFFFFFFFL) &lt;&lt; s) | ((a&amp;0xFFFFFFFFL) &gt;&gt;&gt; (32 - s)); a += b; return (a&amp;0xFFFFFFFFL); &#125; private static long HH(long a, long b, long c, long d, long x, long s, long ac) &#123; a += (H(b, c, d)&amp;0xFFFFFFFFL) + x + ac; a = ((a&amp;0xFFFFFFFFL) &lt;&lt; s) | ((a&amp;0xFFFFFFFFL) &gt;&gt;&gt; (32 - s)); a += b; return (a&amp;0xFFFFFFFFL); &#125; private static long II(long a, long b, long c, long d, long x, long s, long ac) &#123; a += (I(b, c, d)&amp;0xFFFFFFFFL) + x + ac; a = ((a&amp;0xFFFFFFFFL) &lt;&lt; s) | ((a&amp;0xFFFFFFFFL) &gt;&gt;&gt; (32 - s)); a += b; return (a&amp;0xFFFFFFFFL); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MD5</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌浏览器运行安卓APK]]></title>
    <url>%2F2017%2F06%2F25%2F%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C%E5%AE%89%E5%8D%93APK%2F</url>
    <content type="text"><![CDATA[使用谷歌浏览器的插件ARChon实现安卓APK在电脑上运行一些简单的应用可以实现，游戏等可能实现不了用谷歌插件在电脑上运行安卓APK 1，直接谷歌应用商店下载出现错误程序包无效：“CRX_SIGNATURE_VERIFICATION_FAILED”。 2，直接下载crx包参考百度经验3，出现错误：Cannot load extension with file or directory name metadata. Filenames starting with ““ are reserved for use by the system.更改解压后文件夹_metadata为metadata4，出现错误：’import’ extension is not installed.打开文件manifest.json去掉import一句 &lt;span class=&quot;hljs-string&quot;&gt;&quot;import&quot;&lt;/span&gt;: [ { &lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;mfaihdlpglflfgpfjcifdjdjcckigekc&quot;&lt;/span&gt; } ], 继续谷歌去掉这句话不对看这篇CSDN文章说要下载插件ARChon (以下废话，直接看5）4.1，安装成功，但启用后一直白屏 怀疑是不是去掉import一句出问题了4.2，网上看到开启Native Client谷歌浏览器地址栏输入chrome://flags/开启Native Client无用4.3，发现另一个谷歌商店的应用twerk这个应用是把 APK 文件转换成 Chrome App用的5ARChon是谷歌插件要在扩展程序，打钩开发者模式，点击加载已解压扩展程序，选择解压文件夹加载ARChon时有警告，可忽略先加载ARC Welder出现4的错误后再加载ARChon，然后ARC Welder就好了，不好的话重新加载就好了安装好了就是APK运行不了4.3安装的twerk可以把 APK 文件转换一个文件夹然后ARC Welder运行谷歌浏览器如何运行APK博客CSDN可以试一试# 又遇到的问题Chrome加载Android应用，提示“There is no “message” element for key extName”错误，如：解决方法：找到该Crx文件夹下的“_locales\en”目录下的“messages.json”文件，在“extName”节点下，添加“message”字段标签，值对应应用的包名：1WebGL 不受支持知乎有教程浏览器快捷方式属性增加–ignore-gpu-blacklist开启硬件加速试了一下掌阅掌阅.PNG试了一下简书可以运行]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>安卓模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[批处理for循环使用]]></title>
    <url>%2F2017%2F04%2F22%2F%E6%89%B9%E5%A4%84%E7%90%86for%E5%BE%AA%E7%8E%AF%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[windows批处理FOR循环的使用在cmd中输入使用时应写为1FOR %variable IN (set) DO command [command-parameters] command [command-parameters]中用到变量也要写为%variable写进.bat或者.cmd文件时应写为1FOR %%variable IN (set) DO command [command-parameters] command [command-parameters]中用到变量也要写为%%variableWindows自带的help解释:123456FOR %variable IN (set) DO command [command-parameters] %variable 指定一个单一字母可替换的参数。 (set) 指定一个或一组文件。可以使用通配符。 command 指定对每个文件执行的命令。 command-parameters 为特定命令指定参数或命令行开关。 在批处理程序中使用 FOR 命令时，指定变量请使用 %%variable而不要用 %variable。变量名称是区分大小写的，所以 %i 不同于 %I.]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>批处理</tag>
      </tags>
  </entry>
</search>
